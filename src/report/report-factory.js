/**
 * @ngdoc service
 * @name DebtCalculator.Factories:ReportFactory
 * @description
 * Creates and manages report data based on data in the AccountFactory 
 */

var reportFactory = function( AccountFactory, $filter ){ 
	var factory = {};
	
	/**
     * @ngdoc property
     * @name reportData
     * @propertyOf DebtCalculator.Factories:ReportFactory
     * @returns {array} The generated report information after runReport() is executed
     * 
     * @description
     * Contains all the information generated after runReport() is executed
     */
	factory.reportData  = { accounts: [], months : [], interestPaid : 0 };

	/**
     * @ngdoc property
     * @name reportTypes
     * @propertyOf DebtCalculator.Factories:ReportFactory
     * @returns {array} The valid reportTypes
     * 
     * @description
     * The valid report types to execute a report against
     */

    factory.reportTypes = [
		{ name: "Highest APR First", reverse: true, sortAlgorithm: 'APR' },
		{ name: "Lowest Balance First", reverse: false, sortAlgorithm: 'balance' },
		{ name: "Weighted Algorithm", reverse: true, sortAlgorithm: function( account ) {
			return account.payment / account.balance;
		}}
	];

	/**
     * @ngdoc property
     * @name reportTypes
     * @propertyOf DebtCalculator.Factories:ReportFactory
     * @returns {array} The months to be used in the chart
     * 
     * @description
     * The months generated by the report, which will be used on the X-axis of the report
     */
	factory.chartCategories = [];

	/**
     * @ngdoc property
     * @name chartSeries
     * @propertyOf DebtCalculator.Factories:ReportFactory
     * @returns {array} The series to be used in the chart
     * 
     * @description
     * The unique data series and their respective data, which will be used to generate the chart
     */
	factory.chartSeries 	= [];

	/**
     * @ngdoc method
     * @name calculateTotalBalance
     * @methodOf DebtCalculator.Factories:ReportFactory
     * @param {array} accounts The accounts to sum
     * @description
     * Returns the sum of the current balances of the accounts specified
     */
	factory.calculateTotalBalance = function( accounts ) {
		var totalBalance = 0;
		// Initialize the total balance and accounts array
		angular.forEach( accounts, function( item, index ) {

			totalBalance += item.balance;
			factory.reportData.accounts.push( item.name );

		});

		return totalBalance;
	};

	/**
     * @ngdoc method
     * @name runReport
     * @methodOf DebtCalculator.Factories:ReportFactory
     * @param {Object} reportType The reportType object to run the report against
     * @description
     * Executes the report based on the given parameters and sets the factory.reportData property with the results
     */
	
	factory.runReport = function( reportType, extrapayment ) {
		var accounts 	 	= $filter( 'orderBy' )( angular.copy( AccountFactory.accounts ), reportType.sortAlgorithm, reportType.reverse );

		var totalBalance 	= factory.calculateTotalBalance( accounts );
		
		factory.reportData 	= { accounts: [], months : [], interestPaid : 0 };
		factory.chartSeries = [];
		factory.chartCategories = [];
		// Initialize the accounts array
		angular.forEach( accounts, function( item, index ) {
			factory.reportData.accounts.push( item.name );
		});
		
		// Execute the report.  As long as there's a balance, keep iterating.
		// Minimum payment and interest payment related code starts here.
		while ( totalBalance ) {
			// The current report month
			var reportMonth = {
				totalInterest : 0, // Interest for all accounts
				totalBalance  : 0, // Ending balance for all accounts
				accounts	  : [], // Array of account actuals
				name  		  : moment().add( factory.reportData.months.length + 1, 'months' ).format( "MMM 'YY" )
			};

			var totalamountPaid = 0;
			var remainder 		= parseFloat( angular.copy( extrapayment ) );

			// Loop through each account to calculate its maximum of interest and minimum payment for this month
			for ( var i = 0; i < accounts.length; i++ ) {
				var item 			= accounts[ i ];
				var previousBalance = 0;
				var remainderPaid 	= 0;
				var amountPaid 		= 0;

				// If this is the first month, the previous balance is the balance entered by the user.  
				// Otherwise get the ending balance from the previous month
				if ( factory.reportData.months.length ) {
					previousBalance = factory.reportData.months[ factory.reportData.months.length - 1 ].accounts[ i ].endingBalance;
				} else {
					previousBalance = item.balance;
				}
				
				// Determine the amount that will be paid this month comparing amountPaid calculated above and balance.  
				// If the amountPaid exceeds the balance, use the balance.
				if ( previousBalance ) {
					amountPaid = ( item.payment > previousBalance ) ? previousBalance : item.payment;
					
					if ( ( remainder > 0 ) && ( amountPaid < previousBalance ) ) {

						if ( ( amountPaid + parseFloat( remainder ) ) > previousBalance ) {
							remainderPaid = previousBalance - amountPaid;
						} else {
							remainderPaid = angular.copy( remainder );
						}
					}
					
					remainder  = remainder - remainderPaid;
					amountPaid = amountPaid + remainderPaid;
				}

				// Determine what the balance for this account will be after the payment is made
				var balanceAfterPayment = previousBalance - amountPaid;
				
				// Calculate interest to be paid (here, the assumption is interest is added at the end of each month)
				var interestPaid = ( ( item.APR / 100 ) / 12 ) * balanceAfterPayment;
				
				// Calculate balance including interest to be paid
				balanceAfterPayment += interestPaid;
				
				// Add each account monthly amountPaid to total-amountPaid
				totalamountPaid += amountPaid;
				
				// Add the month object to the account array with its respective values
				reportMonth.accounts.push({
					name 			: item.name,
					endingBalance 	: balanceAfterPayment,
					interestPaid 	: interestPaid,
					amountPaid      : amountPaid,
					remainderPaid   : remainderPaid
				});

				factory.reportData.interestPaid += interestPaid;

				// Update the running interest and balance totals
				reportMonth.totalInterest += interestPaid;
				reportMonth.totalBalance += balanceAfterPayment;

				/*
					If the amount paid for this account is less than the monthly payment, apply it to the remainder.
					This will happen if the account is paid off this month or was already paid off
				*/
				//remainder = parseFloat( remainder ) + ( parseFloat( item.payment ) - parseFloat( amountPaid ) );
			}
			
			totalBalance = reportMonth.totalBalance;

			factory.reportData.months.push(reportMonth);
		}

		// Populate the series array with the account information
		angular.forEach( factory.reportData.accounts, function( account, index ) {
			factory.chartSeries.push({
				name: account,
				data: []
			});
		});

		// For each report month, add the balance to the respective series 
		angular.forEach( factory.reportData.months, function( month, monthNDX ) {
			factory.chartCategories.push( month.name );

			angular.forEach( month.accounts, function( account, accountNDX ) {
				factory.chartSeries[ accountNDX ].data.push( account.endingBalance );
			});
		});
		
	};

	return factory;
};

// Register the factory with angular
angular.module( 'debt-calculator' )
	.factory( 'ReportFactory', reportFactory );
